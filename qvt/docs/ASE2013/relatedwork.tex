\section{Related Work}\label{sec:related}

The Kermeta model transformation language development tools include code generators that can transform Kermeta transformations into Java and Scala code which can then be executed against a Java Virtual Machine (JVM) for more efficient execution \cite{Fouquet.etal2010}. The Epsilon\cite{Paige.etal2009} platform of model management languages also features a layered approach where all model task-specific languages extend a common expression language (EOL).

Following the paradigm of VM-based programming language architectures (e.g. JVM), the Atlas Transformation Language (ATL) features a layered architecture in which transformations are compiled to XML-based byte-code, which is then executed by a virtual machine \cite{Jouault.etal2008}. The architecture of ATL enables the substitution of the default VM with custom VM implementations. Beyond the default generic VM, ATL ships with an additional optimized VM for transforming EMF-based models. The ATL VM is based upon the ATL language and so has limited integration with its OCL implementation. The similarities of the QVT and ATL architectures provide interesting points for interoperability\cite{Jouault.Kurtev2006}. In contrast our approach exploits the inherent tree structure of the OCL AST to extend the Eclipse OCL VM's tree-walking interpreter and code generator for the extended QVTi AST. 

Building on the idea of a 2-stage execution of model transformations, in \cite{Wagelaar.etal2011}, the authors present a generic transformation engine VM (EMFTVM). Similarly to the ATL VM, EMFTVM also executes byte-code but unlike the ATL VM where byte-code is represented using proprietary XML, in EMFTVM byte-code conforms to an Ecore metamodel -- and as such it is easier for higher-level transformation languages to compile down to it using higher-order transformations. The aim of EMFTVM is to serve as an underlying VM for additional transformation languages and as a proof of concept, the developer of the EMFTVM has implemented higher-order model transformations that map transformations expressed both in ATL and in a simple graph transformation language\footnote{http://soft.vub.ac.be/soft/research/mdd/simplegt} to VM byte-code. The concept of a reusable EMF-based VM that can act as a compilation target for higher-level languages is similar to the approach proposed in this paper. However, in our approach we envision multiple hook points which will allow transformation languages operating at different levels of abstraction to integrate with the proposed architecture with reduced duplication.

The most similar approach to the one proposed in this paper, is the work presented in \cite{Sanchez-Barbudo.etal2008} where the authors propose a layered architecture for implementing QVTc and QVTo. More specifically, the authors propose a program-to-program transformation to compile QVTc and QVTo transformations into a low-level imperative transformation language called Atomic Transformation Code (ATC), and then compile ATC code to byte-code that can be executed by a proprietary virtual machine called Virtual Transformation Engine (VTE). The architecture of our approach is similar, but we propose to eliminate dependencies on proprietary components (ATC), and to further decompose the compilation process by introducing additional intermediate QVTx languages.
